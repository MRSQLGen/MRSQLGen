from __future__ import annotations
from typing import Any, List, Tuple
from app.MR_checker.MRChecker_factory import get_mr_checker_by_sql_type

class BugDetector:
    """
    BugDetector Class: used to detect whether the SQL generated by the LLM contains hallucination issues.

    Applied in the Validating Component module, its core responsibilities include:
    - Implementing Cross Validation
    - Executing Error Report:
        * Determine whether the original query generated by the LLM (blue TargetResult)
          is logically consistent with multiple metamorphic queries (green MutantResults).
        * If the number of satisfied MRs (Metamorphic Relations) is less than the threshold,
          the SQL is considered to contain hallucination (i.e., semantic instability).
    """

    def __init__(
        self,
        hallu_type: str,
        target_result: Tuple[Any, int, str],
        mutant_results: List[Tuple[Any, int, str]],
        sql_type: str,  # "SELECT" / "INSERT" / "UPDATE" / "DELETE"
        mr_relations: List[str], # mode: （equal / contains / contained_by）
        strict: bool,  # strict:  SELECT （ + ）
        threshold: float
    ) -> None:
        """
        Initialize a BugDetector instance.

        Parameter description:
        - hallu_type: Current hallucination type, used to select the appropriate MR checker
        - target_result: Execution result of the original SQL (format: (result data, row count, error message))
        - mutant_results: Execution results of multiple SQL queries generated by mutated prompts
        - sql_type: SQL type, e.g., "SELECT", "INSERT", "UPDATE", "DELETE"
        - mr_mode: Comparison method to check whether results satisfy the MR
        - strict: Whether to consider order and duplicates in SELECT comparisons
        - threshold: Minimum number of mutants required to satisfy the MR; below this threshold, it is judged as hallucination
        """

        self.hallu_type = hallu_type
        self.target_result = target_result
        self.mutant_results = mutant_results
        self.sql_type = sql_type.upper()
        self.threshold = threshold
        self.mr_relations = mr_relations
        self.strict = strict

    def check_bug(self) -> Tuple[bool, List[bool]]:
        """
        Perform MR checks between each item in mutant_results and target_result, and count how many satisfy the MR.

        Core decision logic:
        - Iterate over each mutant SQL result and compare it with the target_result to determine
          whether it satisfies the defined MR.
        - If the number of mutants satisfying the MR is less than threshold,
          the original SQL is judged to contain hallucination (return True).

        Return values:
        - `is_hallucination`: bool (True indicates hallucination exists, False indicates no hallucination)
        - `num_satisfied_mutants`: int (number of mutants satisfying the MR)
        - `total_mutants`: int (total number of mutants)
        """

        count = 0
        effective = 0
        results_bool = []
        for i, mutant in enumerate(self.mutant_results):
            checker = get_mr_checker_by_sql_type(hallu_type=self.hallu_type, sqlite_exec_one=self.target_result,sqlite_exec_two=mutant, sql_type=self.sql_type)
            check_flag = checker.check(mode=self.mr_relations[i], strict=self.strict)
            results_bool.append(check_flag)
            if type(check_flag) == bool:
                if check_flag:
                    count += 1
                    effective += 1
                    # print(i)
                    # print("target")
                    # print(self.target_result)
                    # print("mutant")
                    # print(mutant)
                    # print("mr_relation")
                    # print(self.mr_relations[i])
                    # print(True)
                else:
                    effective += 1
                    # print(i)
                    # print("target")
                    # print(self.target_result)
                    # print("mutant")
                    # print(mutant)
                    # print("mr_relation")
                    # print(self.mr_relations[i])
                    # print(False)
        return not(count >= self.threshold * effective), results_bool







